# Linux Kernel Module Building

## Overview

Linux kernel modules are pieces of code that can be loaded into and unloaded from the running kernel on demand. This provides the ability to extend kernel functionality without needing to reboot the system or rebuild the entire kernel. The kernel module build system (kbuild) supports both in-tree modules (part of the kernel source tree) and out-of-tree modules (external to the kernel source).

This guide covers comprehensive information about building, installing, signing, and managing kernel modules across various scenarios.

## Key Concepts

### Module Types

**In-tree modules**: Modules that are part of the official kernel source tree. These are built during the normal kernel build process and are located in subdirectories like `drivers/`, `fs/`, `net/`, etc.

**Out-of-tree modules**: Modules developed and built outside the kernel source tree. Also called "external modules," these are often third-party drivers, custom hardware support, or experimental code.

### Module File Formats

- `.ko` - Kernel object (uncompressed module)
- `.ko.gz` - Gzip-compressed module
- `.ko.xz` - XZ-compressed module
- `.ko.zst` - Zstandard-compressed module (Linux 5.13+)

### Build System Components

1. **kbuild** - The kernel build system that processes Makefiles and Kbuild files
2. **Module.symvers** - Contains exported symbols with CRC values for version checking
3. **modules.builtin** - List of modules compiled into the kernel
4. **modules.dep** - Module dependency information (generated by depmod)

## In-Tree Module Building

### Building All Modules

```bash
# Configure kernel with modules enabled
make menuconfig  # Enable CONFIG_MODULES=y

# Build all modules
make modules -j$(nproc)

# Install all modules
sudo make modules_install

# Install to alternate location
sudo make INSTALL_MOD_PATH=/tmp/modules modules_install
```

### Building Specific In-Tree Modules

#### Modern Method (Recommended)

```bash
# Build a specific module by path
make drivers/net/ethernet/intel/e1000/e1000.ko

# Build all modules in a directory
make drivers/net/ethernet/intel/e1000/

# Build entire subsystem
make drivers/usb/
```

#### Using M= Parameter

```bash
# Build specific module directory
make M=drivers/net/wireless/ath/ath9k

# From the module directory
cd drivers/net/wireless/ath/ath9k
make -C /path/to/kernel/source M=$PWD
```

#### Legacy SUBDIRS Method (Deprecated)

```bash
# SUBDIRS is deprecated after Linux 5.3, removed in 5.4
# Use M= instead for modern kernels

# Old syntax (DO NOT USE on kernels 5.4+)
make modules SUBDIRS=drivers/net/wireless

# Replacement syntax
make M=drivers/net/wireless modules
```

**Warning**: The SUBDIRS parameter was completely removed in kernel 5.4. Always use `M=` for modern kernels.

### Build Targets for Modules

```bash
# Prepare kernel for module building
make modules_prepare

# Build modules
make modules

# Install modules
make modules_install

# Install to custom directory
make INSTALL_MOD_PATH=/path/to/install modules_install

# Install with custom subdirectory name (default is "updates")
make INSTALL_MOD_DIR=custom modules_install

# Clean module build artifacts
make modules_clean
```

## Out-of-Tree Module Development

### Basic Makefile Structure

Out-of-tree modules require a Makefile that works with the kernel build system. There are several approaches:

#### Approach 1: Traditional KERNELRELEASE Check

```makefile
ifneq ($(KERNELRELEASE),)
# kbuild part of makefile
obj-m := mymodule.o
mymodule-y := main.o helper.o

else
# normal makefile
KDIR ?= /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

default:
	$(MAKE) -C $(KDIR) M=$(PWD)

modules_install:
	$(MAKE) -C $(KDIR) M=$(PWD) modules_install

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean

help:
	$(MAKE) -C $(KDIR) M=$(PWD) help

.PHONY: default modules_install clean help
endif
```

#### Approach 2: Separate Kbuild File

**Makefile:**
```makefile
KDIR ?= /lib/modules/$(shell uname -r)/build

all:
	$(MAKE) -C $(KDIR) M=$$PWD

clean:
	$(MAKE) -C $(KDIR) M=$$PWD clean

install:
	$(MAKE) -C $(KDIR) M=$$PWD modules_install

.PHONY: all clean install
```

**Kbuild:**
```makefile
obj-m := mymodule.o
mymodule-y := main.o helper.o
ccflags-y := -I$(src)/include
```

#### Approach 3: Direct Kernel Makefile Inclusion (Linux 6.13+)

```makefile
KDIR ?= /lib/modules/$(shell uname -r)/build

# Export module directory
export KBUILD_EXTMOD := $(realpath $(dir $(lastword $(MAKEFILE_LIST))))

# Include kernel makefile directly
include $(KDIR)/Makefile
```

### Building External Modules

```bash
# Build against running kernel
make -C /lib/modules/$(uname -r)/build M=$PWD

# Build against specific kernel source
make -C /usr/src/linux-6.6.1 M=$PWD

# Using -f option (Linux 6.13+) - avoids directory changes
make -f /lib/modules/$(uname -r)/build/Makefile M=$PWD

# Build with output to separate directory
make -C /lib/modules/$(uname -r)/build M=$PWD MO=/tmp/build

# Using KBUILD_EXTMOD environment variable
export KBUILD_EXTMOD=$PWD
make -C /lib/modules/$(uname -r)/build

# Install external module
make -C /lib/modules/$(uname -r)/build M=$PWD modules_install
```

### Multi-File Module Example

**Kbuild or Makefile (kbuild section):**
```makefile
# Single module from multiple source files
obj-m := complex_driver.o
complex_driver-y := main.o
complex_driver-y += hardware.o
complex_driver-y += protocol.o
complex_driver-y += util.o

# Include directories
ccflags-y := -I$(src)/include
ccflags-y += -I$(src)/hal/include

# Conditional compilation
complex_driver-$(CONFIG_DEBUG) += debug.o

# Per-file flags
CFLAGS_main.o := -DVERSION='"$(VERSION)"'
```

### Multiple Modules in One Directory

```makefile
obj-m := module1.o module2.o module3.o

module1-y := module1_main.o module1_helper.o
module2-y := module2_core.o module2_util.o
module3-y := module3.o
```

### Modules in Subdirectories

**Top-level Kbuild:**
```makefile
obj-m := driver1/ driver2/ common/
```

**driver1/Kbuild:**
```makefile
obj-m := driver1.o
driver1-y := main.o hw.o
ccflags-y := -I$(src)/../common/include
```

## Module Compilation Flags

### Compiler Flags

```makefile
# Modern approach (recommended)
ccflags-y := -DDEBUG -O2
ccflags-y += -I$(src)/include
ccflags-y += -Wall -Werror

# Deprecated approach (DO NOT USE)
EXTRA_CFLAGS := -DDEBUG  # Deprecated, use ccflags-y

# Assembler flags
asflags-y := -Wa,-gdwarf-2

# Linker flags for modules
ldflags-y := -T$(src)/custom.lds

# Apply to subdirectories as well
subdir-ccflags-y := -I$(src)/common/include
subdir-asflags-y := -Wa,-gdwarf-2

# Per-file flags
CFLAGS_main.o := -DMODULE_VERSION=1
AFLAGS_entry.o := -DENTRY_POINT
```

### Build-Time Variables

```bash
# Additional compiler flags from command line
make KCFLAGS="-O3 -march=native"

# Module-specific flags
make CFLAGS_MODULE="-DMODULE_DEBUG"

# Assembler flags
make KAFLAGS="-Wa,--gdwarf-5"

# Linker flags for modules
make LDFLAGS_MODULE="-T custom.lds"
```

## Module Dependencies and Symbols

### Module.symvers

The `Module.symvers` file contains exported kernel symbols with their CRC values. Format:

```
<CRC>  <Symbol>  <Module>  <Export Type>  <Namespace>
```

Example:
```
0x12345678  usb_register_driver  vmlinux  EXPORT_SYMBOL_GPL  USB_COMMON
0x87654321  kmalloc  vmlinux  EXPORT_SYMBOL
```

### Building Modules with Dependencies

```bash
# Module A exports symbols
cd module_a
make -C /lib/modules/$(uname -r)/build M=$PWD
# Generates Module.symvers with exported symbols

# Module B depends on Module A
cd module_b
make -C /lib/modules/$(uname -r)/build M=$PWD \
     KBUILD_EXTRA_SYMBOLS=/path/to/module_a/Module.symvers
```

### Multiple Symbol Files

```makefile
# In module's Makefile or Kbuild
KBUILD_EXTRA_SYMBOLS := /path/to/module1/Module.symvers
KBUILD_EXTRA_SYMBOLS += /path/to/module2/Module.symvers
KBUILD_EXTRA_SYMBOLS += /path/to/module3/Module.symvers
```

Or from command line:
```bash
make -C /lib/modules/$(uname -r)/build M=$PWD \
     KBUILD_EXTRA_SYMBOLS="/path/to/mod1/Module.symvers /path/to/mod2/Module.symvers"
```

### Module Versioning (MODVERSIONS)

When `CONFIG_MODVERSIONS` is enabled, the kernel generates CRC checksums for all exported symbols. Modules must be built with matching symbol versions.

**Important**: `make modules_prepare` does NOT generate Module.symvers. You need either:
- A full kernel build: `make -j$(nproc)`
- Or copy Module.symvers from kernel headers package

```bash
# Check if module versioning is enabled
grep CONFIG_MODVERSIONS /boot/config-$(uname -r)

# Build with version checks
make -C /lib/modules/$(uname -r)/build M=$PWD

# Disable version check warnings (for testing only)
make -C /lib/modules/$(uname -r)/build M=$PWD KBUILD_MODPOST_WARN=1
```

## Module Installation

### Installation Paths

Default installation path structure:
```
/lib/modules/$(KERNELRELEASE)/
├── kernel/          # In-tree modules
│   ├── drivers/
│   ├── fs/
│   ├── net/
│   └── ...
├── updates/         # External modules (default)
├── extra/           # Alternative for external modules
├── modules.dep      # Dependency information
├── modules.dep.bin  # Binary dependency database
├── modules.alias    # Device/feature aliases
├── modules.symbols  # Symbol information
└── modules.builtin  # Built-in modules list
```

### Installation Commands

```bash
# Install modules (default to /lib/modules/$(KERNELRELEASE))
sudo make modules_install

# Install to alternate root
sudo make INSTALL_MOD_PATH=/mnt/root modules_install

# Install to custom subdirectory (instead of "updates")
sudo make INSTALL_MOD_DIR=custom modules_install
# Installs to: /lib/modules/$(KERNELRELEASE)/custom/

# Full path override
sudo make MODLIB=/custom/path modules_install

# Install and strip debug symbols
sudo make INSTALL_MOD_STRIP=1 modules_install

# External module installation
sudo make -C /lib/modules/$(uname -r)/build M=$PWD \
     INSTALL_MOD_PATH=/tmp/staging modules_install
```

### Post-Installation Steps

```bash
# Update module dependencies
sudo depmod -a

# Update module dependencies for specific kernel
sudo depmod -a 6.6.1-custom

# Verify module can be found
modprobe -n mymodule  # Dry run
sudo modprobe mymodule  # Actually load

# Check loaded module
lsmod | grep mymodule
modinfo mymodule
```

## Module Signing

Module signing provides cryptographic verification of kernel modules. This is critical for Secure Boot systems and security-conscious environments.

### Configuration Options

```bash
# In kernel configuration (make menuconfig)
CONFIG_MODULE_SIG=y              # Enable signature checking
CONFIG_MODULE_SIG_FORCE=y        # Require valid signatures (restrictive)
CONFIG_MODULE_SIG_ALL=y          # Sign all modules during build
CONFIG_MODULE_SIG_SHA256=y       # Use SHA-256 hash (or SHA-512, etc.)
CONFIG_MODULE_SIG_KEY="certs/signing_key.pem"  # Signing key location
CONFIG_SYSTEM_TRUSTED_KEYS=""    # Additional trusted certificates
```

### Signing Modes

**Permissive mode** (CONFIG_MODULE_SIG_FORCE=n):
- Unsigned modules load but taint the kernel
- Modules with invalid signatures taint the kernel
- Kernel remains functional but marked as compromised

**Restrictive mode** (CONFIG_MODULE_SIG_FORCE=y):
- Only validly signed modules can load
- Unsigned or incorrectly signed modules are rejected
- Required for Secure Boot compliance

### Automatic Signing During Build

When `CONFIG_MODULE_SIG_ALL=y`:

```bash
# Build kernel and modules (automatically signs)
make -j$(nproc)
make modules_install  # Installs signed modules

# Check signature
modinfo mymodule | grep sig
```

### Manual Module Signing

```bash
# Sign a module manually
scripts/sign-file sha256 certs/signing_key.pem \
    certs/signing_key.x509 mymodule.ko

# Sign with custom key
scripts/sign-file sha256 /path/to/private.key \
    /path/to/public.x509 mymodule.ko

# Sign with PKCS#11 token (hardware security module)
scripts/sign-file -p <pin> sha256 "pkcs11:token=MyToken;object=MyKey" \
    /path/to/cert.x509 mymodule.ko

# Verify signature
modinfo mymodule.ko | grep -E "sig_|signer"
```

### Signing External Modules

```bash
# Method 1: Use kernel's signing key (if available)
make -C /lib/modules/$(uname -r)/build M=$PWD
sudo make -C /lib/modules/$(uname -r)/build M=$PWD modules_install

# Method 2: Manual signing after build
make -C /lib/modules/$(uname -r)/build M=$PWD
/usr/src/linux-$(uname -r)/scripts/sign-file sha256 \
    /path/to/signing_key.pem \
    /path/to/signing_key.x509 \
    mymodule.ko
sudo make -C /lib/modules/$(uname -r)/build M=$PWD modules_install

# Method 3: Sign during installation
make -C /lib/modules/$(uname -r)/build M=$PWD \
    KBUILD_SIGN_PIN="password" modules_install
```

### Checking Module Signatures

```bash
# Check if module is signed
modinfo mymodule.ko

# Look for signature fields
modinfo mymodule.ko | grep sig

# Example output:
# sig_id:        PKCS#7
# signer:        Build time autogenerated kernel key
# sig_key:       4F:A7:B9:...
# sig_hashalgo:  sha256
# signature:     30:80:06:09:...

# Check signature validity (loaded module)
dmesg | grep -i signature
```

### Key Management

```bash
# Generate new signing key
openssl req -new -x509 -newkey rsa:2048 -keyout signing_key.pem \
    -outform DER -out signing_key.x509 -nodes -days 36500 \
    -subj "/CN=Custom Module Signing Key/"

# Protect the private key
chmod 600 signing_key.pem

# Configure kernel to use custom key
# Edit .config or use menuconfig:
# CONFIG_MODULE_SIG_KEY="path/to/signing_key.pem"

# For production: Store private key securely, not in kernel tree!
```

### Secure Boot Considerations

```bash
# Enroll key in system MOK (Machine Owner Key) database
sudo mokutil --import signing_key.x509

# After reboot, complete MOK enrollment
# System will prompt during boot

# Verify enrolled keys
mokutil --list-enrolled

# Check if Secure Boot is enabled
mokutil --sb-state
```

## Module Compression

Module compression reduces storage space at the cost of slightly slower load times. Compression happens automatically during `make modules_install`.

### Configuration Options

```bash
# In kernel configuration
CONFIG_MODULE_COMPRESS=y           # Enable compression
CONFIG_MODULE_COMPRESS_GZIP=y      # Use gzip (.ko.gz)
# OR
CONFIG_MODULE_COMPRESS_XZ=y        # Use XZ (.ko.xz)
# OR
CONFIG_MODULE_COMPRESS_ZSTD=y      # Use Zstandard (.ko.zst) [5.13+]
```

### Compression Methods Comparison

| Method | Compression | Speed | Kernel Version | Tool Required |
|--------|-------------|-------|----------------|---------------|
| None   | -           | Fastest | All | - |
| Gzip   | Good        | Fast  | All | kmod with gzip |
| XZ     | Best        | Slow  | All | kmod with xz |
| Zstd   | Very Good   | Very Fast | 5.13+ | kmod 28+ |

### Automatic Compression

```bash
# Configure compression in kernel config
make menuconfig
# Navigate to: Enable loadable module support -> Module compression
# Select compression method

# Build and install (compression happens automatically)
make modules -j$(nproc)
sudo make modules_install

# Verify compressed modules
ls -lh /lib/modules/$(uname -r)/kernel/drivers/net/
# Output: module.ko.xz or module.ko.gz or module.ko.zst
```

### Space Savings Example

Real-world compression results:
```
Uncompressed:  265 MB
Gzip (-9):     110 MB  (58% reduction)
XZ (-9):        91 MB  (66% reduction)
Zstd (-19):     95 MB  (64% reduction, much faster decompression)
```

### Manual Compression

```bash
# Gzip compression (level 9 = maximum)
gzip -9 mymodule.ko
# Creates: mymodule.ko.gz

# XZ compression (level 9 = maximum)
xz -9 mymodule.ko
# Creates: mymodule.ko.xz

# Zstd compression (level 19 = high compression)
zstd -19 mymodule.ko
# Creates: mymodule.ko.zst

# Decompress for inspection
gunzip -c mymodule.ko.gz > mymodule.ko
xz -d mymodule.ko.xz
zstd -d mymodule.ko.zst
```

### Loading Compressed Modules

Compression is transparent to users:

```bash
# Works the same regardless of compression
sudo modprobe mymodule
sudo insmod /lib/modules/$(uname -r)/kernel/drivers/mymodule.ko.xz

# modinfo works on compressed modules
modinfo mymodule
```

### Compression Requirements

**kmod** (module-init-tools replacement) must be built with compression support:

```bash
# Check kmod capabilities
kmod --version

# Debian/Ubuntu: Install kmod with compression
sudo apt install kmod

# Build kmod with all compression support
./configure --with-zlib --with-xz --with-zstd
make && sudo make install
```

### Initramfs Considerations

```bash
# Important: Compress whole initramfs, not individual modules
# Module compression in initramfs is less efficient

# If using compressed modules in initramfs:
# 1. Ensure initramfs builder supports it
mkinitramfs -o /boot/initramfs.img $(uname -r)

# 2. Or decompress modules for initramfs
find /lib/modules/$(uname -r)/kernel -name "*.ko.xz" \
    -exec xz -d {} \; -exec mv {}.ko {} \;
```

## Module Stripping

Stripping removes debug symbols from modules to save space. This is separate from compression.

### Installation with Stripping

```bash
# Strip modules during installation (default strip)
sudo make INSTALL_MOD_STRIP=1 modules_install

# Custom strip flags
sudo make INSTALL_MOD_STRIP="--strip-debug --keep-file-symbols" \
    modules_install

# No stripping (preserve all symbols)
sudo make INSTALL_MOD_STRIP=0 modules_install
```

### Manual Stripping

```bash
# Strip debug symbols only (recommended)
strip --strip-debug mymodule.ko

# Strip all symbols (smaller but harder to debug)
strip --strip-unneeded mymodule.ko

# Check module size before/after
ls -lh mymodule.ko

# Verify module still works
modinfo mymodule.ko
sudo insmod mymodule.ko
```

## Kernel Headers and Module Building

### Preparing Kernel for External Modules

```bash
# From kernel source directory

# Minimal preparation (fast, but no Module.symvers)
make modules_prepare

# Full preparation (includes Module.symvers)
make modules -j$(nproc)

# Install headers for external module building
sudo make headers_install INSTALL_HDR_PATH=/usr/local
```

### Using Distribution Kernel Headers

```bash
# Debian/Ubuntu
sudo apt install linux-headers-$(uname -r)

# RHEL/CentOS/Fedora
sudo dnf install kernel-devel-$(uname -r)

# Arch Linux
sudo pacman -S linux-headers

# Build against distribution headers
make -C /lib/modules/$(uname -r)/build M=$PWD
```

### Building for Different Kernel Version

```bash
# Build module for specific kernel version
make -C /lib/modules/6.6.1-custom/build M=$PWD

# Cross-version compatibility
# Note: Module must be compatible with target kernel ABI
```

### Header Installation Layout

```
/lib/modules/$(uname -r)/
├── build -> /usr/src/linux-headers-$(uname -r)  # Symlink to headers
└── source -> /usr/src/linux-source-$(uname -r)  # Symlink to source (optional)

/usr/src/linux-headers-$(uname -r)/
├── Makefile
├── Module.symvers
├── .config
├── include/
├── arch/
├── scripts/
└── ...
```

## Common Build Scenarios

### Scenario 1: Simple Single-File Module

**hello.c:**
```c
#include <linux/module.h>
#include <linux/kernel.h>

static int __init hello_init(void) {
    printk(KERN_INFO "Hello, kernel!\n");
    return 0;
}

static void __exit hello_exit(void) {
    printk(KERN_INFO "Goodbye, kernel!\n");
}

module_init(hello_init);
module_exit(hello_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Developer");
MODULE_DESCRIPTION("A simple example module");
```

**Makefile:**
```makefile
obj-m := hello.o

KDIR := /lib/modules/$(shell uname -r)/build

all:
	$(MAKE) -C $(KDIR) M=$$PWD

clean:
	$(MAKE) -C $(KDIR) M=$$PWD clean

install:
	sudo $(MAKE) -C $(KDIR) M=$$PWD modules_install
	sudo depmod -a

.PHONY: all clean install
```

**Build and test:**
```bash
make
sudo insmod hello.ko
dmesg | tail
sudo rmmod hello
dmesg | tail
```

### Scenario 2: Multi-File Module with Headers

**Directory structure:**
```
mydriver/
├── Makefile
├── Kbuild
├── main.c
├── hardware.c
├── protocol.c
└── include/
    ├── mydriver.h
    └── hw_defs.h
```

**Kbuild:**
```makefile
obj-m := mydriver.o
mydriver-y := main.o hardware.o protocol.o
ccflags-y := -I$(src)/include -Wall -Werror
```

**Makefile:**
```makefile
KDIR ?= /lib/modules/$(shell uname -r)/build

all:
	$(MAKE) -C $(KDIR) M=$$PWD modules

clean:
	$(MAKE) -C $(KDIR) M=$$PWD clean

install:
	sudo $(MAKE) -C $(KDIR) M=$$PWD modules_install
	sudo depmod -a

.PHONY: all clean install
```

### Scenario 3: Multiple Independent Modules

**Kbuild:**
```makefile
obj-m := driver1.o driver2.o utils.o

driver1-y := driver1_main.o driver1_hw.o
driver2-y := driver2_main.o driver2_protocol.o
utils-y := utils.o

ccflags-y := -I$(src)/include
```

### Scenario 4: Module with Subdirectories

**Top-level structure:**
```
project/
├── Makefile
├── Kbuild
├── core/
│   ├── Kbuild
│   └── core.c
├── drivers/
│   ├── Kbuild
│   ├── net_driver.c
│   └── block_driver.c
└── include/
    └── common.h
```

**Top-level Kbuild:**
```makefile
obj-m := core/ drivers/
ccflags-y := -I$(src)/include
```

**core/Kbuild:**
```makefile
obj-m := core.o
```

**drivers/Kbuild:**
```makefile
obj-m := net_driver.o block_driver.o
```

### Scenario 5: Conditional Compilation

**Kbuild:**
```makefile
obj-m := mymodule.o

mymodule-y := main.o common.o

# Conditional object files based on config
mymodule-$(CONFIG_FEATURE_A) += feature_a.o
mymodule-$(CONFIG_FEATURE_B) += feature_b.o

# Debug build
ccflags-$(CONFIG_DEBUG) := -DDEBUG -g
ccflags-y += -I$(src)/include
```

**Using from make:**
```bash
# Enable features via environment
make CONFIG_FEATURE_A=y CONFIG_FEATURE_B=y CONFIG_DEBUG=y
```

### Scenario 6: Building Against Custom Kernel

```bash
# Download and extract kernel source
wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.6.1.tar.xz
tar xf linux-6.6.1.tar.xz
cd linux-6.6.1

# Configure kernel
make defconfig
make menuconfig  # Ensure CONFIG_MODULES=y

# Build kernel (needed for Module.symvers)
make -j$(nproc)

# Build your external module
cd /path/to/mymodule
make -C /path/to/linux-6.6.1 M=$PWD
```

### Scenario 7: Cross-Compilation for ARM

```bash
# Install cross-compiler
sudo apt install gcc-aarch64-linux-gnu

# Build kernel for ARM64
cd /path/to/kernel
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc)

# Build module for ARM64
cd /path/to/mymodule
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- \
     -C /path/to/kernel M=$PWD
```

### Scenario 8: Debugging Module Build

```bash
# Verbose build showing all commands
make V=1

# Show why files are rebuilt
make V=2

# Keep preprocessed files for inspection
make drivers/mydriver/main.i

# Generate assembly output
make drivers/mydriver/main.s

# Generate mixed source/assembly listing
make drivers/mydriver/main.lst

# Check with sparse static analyzer
make C=2 drivers/mydriver/

# Enable extra warnings
make W=1 drivers/mydriver/
```

## Module Loading and Management

### Loading Modules

```bash
# Load module with modprobe (handles dependencies)
sudo modprobe mymodule

# Load with parameters
sudo modprobe mymodule param1=value1 param2=value2

# Load module directly with insmod (no dependency resolution)
sudo insmod /path/to/mymodule.ko

# Load with parameters
sudo insmod /path/to/mymodule.ko param1=value1
```

### Unloading Modules

```bash
# Unload module
sudo modprobe -r mymodule

# Force unload (dangerous!)
sudo modprobe -rf mymodule

# Remove with rmmod
sudo rmmod mymodule

# Force remove (dangerous!)
sudo rmmod -f mymodule
```

### Module Information

```bash
# Show module information
modinfo mymodule
modinfo /path/to/mymodule.ko

# List loaded modules
lsmod

# Show specific module details
lsmod | grep mymodule

# Show module parameters
systool -v -m mymodule

# Check module dependencies
modprobe --show-depends mymodule

# Dry-run module load
modprobe -n mymodule

# Show what module would be loaded
modprobe --show mymodule
```

### Module Parameters

**In module code:**
```c
#include <linux/moduleparam.h>

static int debug = 0;
module_param(debug, int, 0644);
MODULE_PARM_DESC(debug, "Enable debug output (default: 0)");

static char *device = "default";
module_param(device, charp, 0444);
MODULE_PARM_DESC(device, "Device name");
```

**At load time:**
```bash
sudo modprobe mymodule debug=1 device="custom"
```

**After loading:**
```bash
# View parameter
cat /sys/module/mymodule/parameters/debug

# Modify parameter (if writable)
echo 2 | sudo tee /sys/module/mymodule/parameters/debug
```

### Automatic Module Loading

**Method 1: /etc/modules**
```bash
# Add module name to load at boot
echo "mymodule" | sudo tee -a /etc/modules
```

**Method 2: /etc/modules-load.d/**
```bash
# Create a .conf file
sudo tee /etc/modules-load.d/mymodule.conf <<EOF
mymodule
EOF
```

**Method 3: Module aliases (udev)**
```bash
# /etc/modprobe.d/mymodule.conf
alias char-major-10-200 mymodule
```

### Module Parameters Configuration

**Persistent parameters: /etc/modprobe.d/mymodule.conf**
```bash
# Set default parameters
options mymodule debug=1 device="custom"

# Blacklist module
blacklist mymodule

# Soft dependency (load order)
softdep mymodule pre: dependency1 post: dependency2

# Custom install command
install mymodule /sbin/modprobe --ignore-install mymodule && /usr/local/bin/setup.sh

# Custom remove command
remove mymodule /usr/local/bin/cleanup.sh && /sbin/modprobe -r --ignore-remove mymodule
```

## Troubleshooting

### Build Errors

**Error: "No rule to make target"**
```bash
# Solution: Ensure kernel is properly configured
make modules_prepare

# Or full build
make -j$(nproc)
```

**Error: "Module version mismatch"**
```bash
# Solution: Rebuild with correct Module.symvers
# Copy from kernel build or distribution package
cp /usr/src/linux-headers-$(uname -r)/Module.symvers .
make clean && make
```

**Error: "modpost: symbol not found"**
```bash
# Solution: Add KBUILD_EXTRA_SYMBOLS
make KBUILD_EXTRA_SYMBOLS=/path/to/dependency/Module.symvers

# Or disable warnings for testing
make KBUILD_MODPOST_WARN=1
```

**Error: "Invalid module format"**
```bash
# Check kernel version mismatch
modinfo mymodule.ko | grep vermagic
uname -r

# Rebuild for correct kernel
make -C /lib/modules/$(uname -r)/build M=$PWD clean
make -C /lib/modules/$(uname -r)/build M=$PWD
```

### Load Errors

**Error: "Invalid module format"**
```bash
# Kernel version mismatch
# Rebuild module for running kernel
make -C /lib/modules/$(uname -r)/build M=$PWD clean
make -C /lib/modules/$(uname -r)/build M=$PWD
sudo make -C /lib/modules/$(uname -r)/build M=$PWD modules_install
```

**Error: "Required key not available"**
```bash
# Module signing issue with Secure Boot
# Option 1: Sign the module
sudo /usr/src/linux-$(uname -r)/scripts/sign-file \
    sha256 /path/to/key.pem /path/to/key.x509 mymodule.ko

# Option 2: Disable Secure Boot (in BIOS/UEFI)

# Option 3: Add key to MOK
sudo mokutil --import /path/to/key.x509
```

**Error: "Unknown symbol in module"**
```bash
# Missing dependency or symbol version mismatch
# Check dependencies
modprobe --show-depends mymodule

# Check for missing symbols
dmesg | grep -i unknown

# Load dependency first
sudo modprobe dependency_module
sudo modprobe mymodule

# Or rebuild with correct symbols
```

**Error: "Module is already loaded"**
```bash
# Unload first
sudo rmmod mymodule
sudo modprobe mymodule
```

### Debugging Techniques

```bash
# Enable dynamic debug for module
echo 'module mymodule +p' | sudo tee /sys/kernel/debug/dynamic_debug/control

# Check kernel messages
dmesg | tail -50
journalctl -k -f  # Follow kernel messages

# Check module sections and symbols
readelf -S mymodule.ko
nm mymodule.ko

# Verify module dependencies
ldd mymodule.ko  # Won't work, modules use kernel symbols
modprobe --show-depends mymodule

# Check module loading path
strace -e openat modprobe mymodule 2>&1 | grep "\.ko"
```

## Best Practices

### Development Workflow

1. **Start simple**: Begin with a minimal module and test it
2. **Incremental changes**: Add features incrementally, testing each step
3. **Version control**: Use git to track changes
4. **Test thoroughly**: Test loading, unloading, and functionality
5. **Check logs**: Always check dmesg after loading/unloading

### Code Quality

```bash
# Check coding style
scripts/checkpatch.pl --file mymodule.c

# Static analysis
make C=2 M=$PWD

# Enable extra warnings
make W=1 M=$PWD
```

### Security Considerations

1. **Sign modules** for production systems
2. **Validate inputs** from userspace
3. **Protect private keys** (never commit to git)
4. **Use proper locking** for concurrent access
5. **Check return values** from kernel functions

### Performance

1. **Minimize init time**: Keep module_init() fast
2. **Use appropriate locks**: Avoid holding locks too long
3. **Defer work**: Use workqueues for slow operations
4. **Profile code**: Use ftrace and perf for analysis

### Distribution

```bash
# Create DKMS package for automatic rebuilds
# /usr/src/mymodule-1.0/dkms.conf
PACKAGE_NAME="mymodule"
PACKAGE_VERSION="1.0"
BUILT_MODULE_NAME[0]="mymodule"
DEST_MODULE_LOCATION[0]="/updates"
AUTOINSTALL="yes"

# Install DKMS module
sudo dkms add -m mymodule -v 1.0
sudo dkms build -m mymodule -v 1.0
sudo dkms install -m mymodule -v 1.0
```

## References

### Official Documentation

- `Documentation/kbuild/modules.rst` - Building external modules
- `Documentation/kbuild/makefiles.rst` - Makefile syntax and structure
- `Documentation/kbuild/kbuild.rst` - Kbuild variables
- `Documentation/admin-guide/module-signing.rst` - Module signing
- `Documentation/kbuild/kconfig.rst` - Configuration system

### Online Resources

- Linux Kernel Documentation: https://docs.kernel.org/kbuild/
- Kernel Newbies: https://kernelnewbies.org/
- Linux Driver Development: https://lwn.net/Kernel/LDD3/

### Key Kernel Files

- `Makefile` - Top-level kernel makefile
- `scripts/Makefile.modpost` - Module post-processing
- `scripts/Makefile.build` - Object compilation rules
- `scripts/sign-file` - Module signing tool
- `scripts/mod/modpost.c` - Module symbol processing

### Man Pages

```bash
man modprobe
man modinfo
man depmod
man insmod
man rmmod
man modprobe.d
```
